## 연산
==연산자(Operator)==: 연산에 사용되는 표시나 기호 (+, -, /, * ...)
==피연산자(Operand)==: 연산되는 데이터 (변수 등)
==연산식(Expression)==: 연산자와 피연산자를 기술한 연산 과정

**자바의 연산자**

| 연산자 종류 | 연산자                            | 피연산자 수 | 산출값  | 기능                      |
| ----------- | --------------------------------- | ----------- | ------- | ------------- |
| 산술        | +,-,\*,/,%                        | 이항        | 숫자    | 사칙연산 및 나머지 계산   |
| 부호        | +,-                               | 단항        | 숫자    | 음수와 양수의 부호        |
| 문자열      | +                                 | 이항        | 문자열  | 두 문자열을 연결          |
| 대입        | =,+=,-=,\*=,/=,%=                 | 이항        | 다양    | 우변의 값을 좌변에 대입   |
| 증감        | ++, --                            | 단항        | 숫자    | 1만큼 증가/감소           |
| 비교        | \==, !=, >, <, >=, <=, instanceof | 이항        | boolean | 값의 비교                 |
| 논리        | !, &, \|, &&, \|\|                | 단항, 이항  | boolean | 논리 부정, 논리곱, 논리합 |
| 조건        | (조건식)?A:B                      | 삼항        | 다양    | 조건식에 따라 A, B 중 선택 |

==나눗셈의 몫==은 그냥 변수를 int로 선언해서 소수점을 지우는 게 일반적인 듯

- 연산식은 반드시 **하나의 값을 산출**
- 하나의 값이 오는 모든 자리에 연산식 사용 가능
- 변수에 연산식의 값을 저장
```java
int result = x+y;
```
- 다른 연산식의 피연산자 위치에 연산식 대입 가능
```java
boolean result = (x+y) < 5; //true | false 저장
```


###  연산의 방향과 우선순위
- 연산은 **우선 순위에 따라 수행**
	- 단항 → 이항 → 삼항
	- 산술 → 비교 → 논리 → 대입
```java
x > 0 && y < 0
// 1. >, <의 비교 연산
// 2. &&의 논리 연산
```

- 우선 순위가 같은 연산자는 **왼쪽 → 오른쪽**

- ==예외==: 단항 연산자(++, --, ~, !), 부호 연산자(+, -), 대입 연산자 (=, +=, -=, ...)는 **오른쪽에서 왼쪽으로** 연산
![](https://i.imgur.com/8LXNLSQ.png)


- **괄호()** 를 사용하면 연산식을 묶을 수 있음
```java
int result = (x+y)*z // (x+y)를 먼저 수행
```


### 연산자의 종류

- 피연산자 수에 따라 단항, 이항, 삼항 연산자로 구분

#### 단항 연산자
##### 부호 연산자(+,-)
boolean과 char 타입을 제외한 기본 타입에 사용
| 연산식       | 설명                 |
| ------------ | -------------------- |
| +(피연산자)  | 피연산자의 부호 유지 |
| -(피연산자)) | 피연산자의 부호 변경 |
- (-1)을 곱하는 것과 같다
- 부호 연한의 결과는 ==int로 변환==된다.
```java
byte x = 100;
byte y = -x; // (-x)는 int이므로 컴파일 에러 발생
```

##### 증감 연산자 (++, --)
boolean 타입 외 모든 기본 타입에 사용 가능<br>| 연산식       | 설명                           |
| ------------ | ------------------------------ |
| ++(피연산자) | 다른 연산 전에 피연산자 1 증가 |
| --(피연산자) | 다른 연산 전에 피연산자 1 감소 |
| (피연산자)++ | 다른 연산 후에 피연산자 1 증가 |
| (피연산자)--   | 다른 연산 후에 피연산자 1 감소 |

```java
int x = 1;
int y = 1;

int result1 = ++x + 10;
>>> result1: 12 //x에 1이 더해진 뒤 result1에 대한 연산 진행
>>> x: 2

int result2 = y++ + 10;
>>> result1: 11 //result2에 대한 연산이 끝난 후에
>>> y: 2 //y에 1이 더해지므로 result2 연산에는 영향이 없음
```

##### 논리 부정 연산자(!)
- true와 false를 서로 반전
	- 조건문/제어문에서 해당 값을 수정하여 실행 제어
	- 토글(toggle)로써 기능
- boolean 타입에만 사용 가능

| 연산식      | 설명                       |
| ----------- | -------------------------- |
| !(피연산자) | true → false, false → true |


#### 이항 연산자
##### 산술 연산자(+, -, \*, /, %)
- 피연산자 타입이 ==동일하지 않은 경우== 아래 규칙에 따라 일치시켜 연산 수행
	- 피연산자가 byte, short, char일 경우, **모두 int로 변환**
	- 피연산자가 모두 정수 타입이며 long을 포함할 경우, **모두 long으로 변환**
	- 피연산자 중 실수 타입이 있을 경우, **해당 실수 타입으로 변환**
	- 정수/정수로 실수가 발생했을 경우, **여전히 정수타입이기 때문에 소수 부분은 버림된다**

```java
char c1 = 'A' + 1;
>>> 'B' //'A' 유니코드에 1을 더해 'B' 출력

char c2 = c1 + 1; //정수와 정수의 연산이므로 c1이 자동으로 int로 변환됨
>>> Error

char c2 = (char)(c1 + 1); //char로 강제변환하면 정상적으로 작동
>>> 'C'
```

##### 문자열 결합 연산자(+)
\+ 연산자의 피연산자 중 한 쪽이 문자열인 경우
==왼쪽에서 오른쪽으로== 연산 진행
```java
String str1 = "JDK" + 6.0 + 3.0;
>>> "JDK6.03.0" //왼쪽부터 연산 진행

String str2 = 6.0 + 3.0 + "JDK";
>>>"9.0JDK"
```

##### 비교 연산자(\==, !=, >, >=, <, <=)
피연산자와 비교하여 ==true/false==를 출력
동등 비교 연산자는 **모든 타입에 사용 가능**
크기 비교 연산자는 boolean 외 모든 기본 타입에 사용 가능

| 구분                     | 연산식                        | 설명             |
| ------------------------ | -------------------------- | --------------- |
| 동등 비교                | 피연산자 == 피연산자<br>피연산자 ! = 피연산자  | 두 값이 같은지 검사<br>두 값이 다른지 검사 |
| 크기 비교                | 피연산자 > 피연산자<br>피연산자 < 피연산자<br>피연산자 >= 피연산자<br>피연산자 <= 피연산자 |왼쪽이 큰지 검사<br>오른쪽이 큰지 검사<br>왼쪽이 크거나 같은지 검사<br>오른쪽이 크거나 같은지 검사                                            |

- 정수 타입, float, double은 각각 정밀도가 다르기 때문에 ==\== 연산자를 사용하면 false 출력==
```java
double var1 = 0.1;
float var2 = 0.1f;
var1 == var2;
>>> false //var1은 double, var2는 float이기 때문에 정밀도가 달라 float 출력
```

##### 논리 연산자
boolean 타입만 사용 가능

![](https://i.imgur.com/8fPjPag.png)

```java
int a = 5;

if ((a >= 3) & (a <= 7));
>>> true

if ((a <= 3) & (a <= 7));
>>> false // &은 두 조건 모두 충족해야 하는데 (a <= 3)은 false

if ((a <= 3) | (a <= 7));
>>> true // |은 둘 중 하나만 충족하면 되므로 true
```

##### 복합 대입 연산자
![](https://i.imgur.com/CGjtxfI.png)

왼쪽 변수에 오른쪽 값을 연산해주는 것과 같은 결과


#### 삼항 연산자 (? :)
3개의 피연산자를 필요로 하는 연산자
? 앞의 조건식에 따라 : 앞뒤의 피연산자 선택
![](https://i.imgur.com/3au5YhU.png)

```java
int score = 95;
String grade = (x > 90) ? "A" : "B";
>>> "A" // (x>90)이 true이기 때문에 좌항 "A" 선택
// 조건문과 비슷한 결과
```



## 조건문
조건식에 따라 다른 실행문을 실행하기 위해 사용
==if문==: 조건식 결과의 true / false 여부에 따라 실행문 결정

==switch문==: 변수 값에 따라 실행문 결정
- Ex) 변수가 x일 경우 / 변수가 y일 경우 / 변수가 x, y 모두 아닐 경우
- 

### if문
- 조건식에 올 수 있는 요소
	- true / false를 산출하는 연산식
	- boolean 타입의 **변수**
- 중괄호 블록은 ==조건식이 true일 때 실행==
	- 명령문이 하나뿐일 경우 중괄호 생략 가능

```java
	int score = 90;

	if (score >= 90) {
		System.out.println("점수가 90보다 큽니다.");
		System.out.println("등급은 A입니다.");
	}

	if(score < 90)
		System.out.prinln("wjatnrk 90보다 작습니다.");
		// 조건문에 속하는 명령문이 하나이므로 중괄호 생략 가능
```

==**if-else문**==
- if문을 else 블록과 함께 사용
- 조건식의 결과에 따라 실행 블록 선택
	- true일 경우 if 블록 실행
	- false일 경우 else 블록 실행

```java
	int score = 85;
	
	if(score >= 90) {
		System.out.println("점수가 90보다 큽니다.");
	} else {
		System.out.println("점수가 90보다 작습니다.");
	}
```

==**if-else if-else문**==
- 조건문이 여러 개 존재하는 ifans
- 첫 if문의 조건식이 false일 경우 다른 조건식과 다시 비교 (≒ elif)
	- if 블록 끝에 else if 문 추가
	- else if문 개수는 제한이 없다.

```java
	int score = 75;
	
	if(score >= 90){ //통과
		System.out.println("점수가 100~90점입니다.");
	}else if(score>=80){ㅏ //통과
		System.out.println("점수가 89~80점입니다.");
	}else{ //당첨
		System.out.println("점수가 79점 이하입니다.");
	}
```


### switch문
==**switch문**==
- **변수가 어떤 값을 갖는가**에 따라 실행문 선택
- if문보다 코드가 간결
- 실행문 마지막에 break를 넣어 조건문 탈출 (의도적으로 break를 사용하지 않을 수도 있음)
- default는 파이썬의 else와 같은 역할

```java
	switch(x){
		case 1: //정수 대신 실수나 문자열이 올 수도 있음
			x==1일 때 실행문;
			break; //break가 없으면 x==1이더라도 switch문을 빠져나가지 않고
			// 다음 조건문에 계속 적용
		case 2:
			x==2일 때 실행문;
			break;
		case 3:
		case 4:
			x==3 or x==4일 때 실행문;
			break;
		default
			그 외 나머지에 대한 실행문;
			break; //마지막 조건문에는 break를 넣지 않아도 됨
	}
			
```



## 반복문
반복 작업을 실행하기 위해 사용

- ==for문==: **반복 횟수를 알고 있을 때** 주로 사용
- ==while문==: **조건에 따라 반복할 때** 주로 사용
- ==do-while문==: while문과 유사하나 **조건을 나중에 검사**


### for문
반복 횟수를 지정하여 반복하고 싶을 때 사용

```java
	for (int i=1; i<=100; i++) { //i가 1부터 100까지, 1씩 커진다는 뜻 → 100번 반복
		반복할 실행문; //파이썬처럼 i 사용 가능
	}
```

```java
	for (float x=0.1f; x<=1.0; x+=0.1f){ //int인 경우와 다르게 아주 작은 소수점이 자동으로 포함되어 1.0이 되지 못 함. 따라서 정수를 사용하는 것이 안전함.
		반복할 실행문;
	}
```

==**중첩 반복문**==
```java
	for (int m=1; m<=100; m++){ //m을 100번 반복하는데
		for (int n=1; n<=10; n++){ //m 1번 마다 n을 10번 반복, 총 1,000번
			반복할 실행문;
		}
	}
```


### while문
- **조건식**에 따라 반복 여부를 결정
	- true일 경우 반복
	- false일 경우 반복 종료
- 주로 비교 연산식, 논리 연산식 사용
- 실행문 안에 조건문을 탈출할 수 있는 방법이 있어야 탈출 가능
	- 탈출 방법이 구현되어 있지 않으면 프로그램을 강제로 종료해야 함

```java
	int x = 6;
	
	while(x<=10){ // x가 10보다 같거나 작은 동안 계속 반복
		반복할 명령문;
	}
```


### do-while문
조건에 의해 반복한다는 점은 while문과 같지만
==**우선 실행문을 한 번 실행한 후에**== 조건을 확인하므로, 실행문을 무조건 한 번은 실행한다는 점에서 다름

```java
	int x = 10;
	
	do {
		반복할 명령문;
	} while (x <= 5); //조건은 false이지만 do-while으므로 한 번은 실행
```


### break문
반복문을 중지할 때 사용하며 주로 **if문과 함께 사용**
break문을 만나면 반복문을 탈출한다.
```java
	int num = 0;
	
	while(true){
		num++;
		System.out.println(num);
		if (num==6){
			break
		}
	}
```

중첩 반복문 안에 break를 사용할 경우, ==break가 속한 블록만 탈출==한다.
따라서 중첩 반복문 전체를 탈출하기 위해서는 **라벨(Label)**\을 사용한다.
```java
	Outter: // 라벨(Label)
	for(int i =1; i<=10; i++){
		for(int k=1; k<=10; k++){
			반복할 명령문
			if(조건문){
				break Outter; // Outter 라벨이 붙은 반복문 전체를 탈출
			}
		}
	}
```


### continue문
for, while, do-while문에서만 사용
for문의 증감식이나 while, do-while문의 조건식으로 이동
==진행중이던 반복을 중지하고 **반복문의 처음으로 다시 돌아가는 역할**==
```java
	for(int i=1, i<=10; i++){
		if(i%2 != 0){ // i가 홀수라면
			continue; // 반복문의 처음으로 복귀
		System.out.println(i)
		}
	}
>>> 2 4 6 8 10
```

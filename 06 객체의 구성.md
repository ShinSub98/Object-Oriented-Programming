==**인스턴스 멤버**==: 객체의 필드와 메소드
- 인스턴스(객체) 필드: 객체마다 가지고 있는 멤버로, 객체마다 다른 데이터를 저장
- 인스턴스(객체) 메소드: 객체를 통해야만 호출할 수 있는 메소드. 클래스 코드(메모리 영역)에 위치하고 있지만 **객체가 가지고 있는 메소드**라고 생각해도 무방함

==**정적 멤버==**: **객체 없이 불러올 수 있는 멤버**로, 클래스 코드(메소드 영역)에 위치하고 있음
- 정적 필드 및 상수: 객체 없이 클래스만으로도 사용 가능한 **필드**
- 정적 메소드: 객체 없이 클래스만으로 호출 가능한 메소드

==**인스턴스 멤버 vs. 정적 멤버**== 선택 기준
- **필드**
	- 필드값이 객체마다 달라야 한다(Ex. 레벨 등) → **인스턴트 필드**
	- 객체마다 필드값이 똑같다(Ex. 도감 번호 등) → **정적 필드**

- **메소드**
	- 메소드 블록에 인스턴트 멤버가 있다 → **인스턴트 메소드**
	- 메소드에 인스턴트 멤버가 없다 → **정적 메소드**


## 인스턴스 멤버와 정적 멤버
### 인스턴스 멤버
==**객체를 생성한 후 사용할 수 있는 필드와 메소드**==
```java
public class Car {
	//필드
	int gas;
	
	//메소드
	void setSpeed(int speed){
	
	}
}
```

### this
==**같은 객체 안의 인스턴스 멤버에 접근**==하기 위해 사용 (즉, 정적 멤버는 this를 사용할 수 없다.)
생성자와 메소드의 매개변수명이 동일한 경우, **필드와 같은 이름을 사용하기 위해 주로 사용**
```java
Car(String model){
	this.model = model;
	//이 model이라는 변수가 어디의 model인지 알 수 없기 때문에
	//"지금 이 객체 안에 있는 model이라는 필드다"라는 의미
}
```



### 정적 멤버
클래스에 고정된 멤버로서, ==**객체를 생성하지 않고 사용할 수 있는 필드와 메소드**==

**정적 멤버 선언**: static
```java
//정적 필드
static String pikachu = "Pika!"; //static 예약어를 사용

//정적 메소드
static int poke(int level){ //static 예약어 사용
	//~ 소스 ~
}
```

**정적 멤버 사용**
클래스 이름를 통해 호출
```java
//클래스
public class Pikachu{
	//정적 필드
	static String pika = "Pika!";
	
	//정적 메소드
	static int poke(int level){
	
	}
}

//-------
	//실행 클래스
	String poke = Pikachu.pika; //클래스명.필드명
	
	int lev = Pikachu.poke(50); //클래스명.메소드명
```


**정적 메소드 선언 시 주의사항**
- 정적 메소드는 ==**정적 멤버만 부를 수 있다.**==
- **this 예약어 사용 불가**

- ==**main() 메소드는 항상 부르는 입장이므로 정적 메소드**==
```java
public static void main(String[] args){
}
```

==**메인 메소드는 프로그램을 실행했을 때, 가장 먼저 실행된다!!**==
```java
public class Car{
	int speed = 50;
	
	void run() {
		System.out.println(speed)
		//4. 인스턴스 메소드이기 때문에 인스턴스 필드인 speed 호출 가능
	}
	
	public static void main(String[] args) { //1. main() 메소드이므로 가장 먼저 실행
		Car myCar = new Car(); //2. Car 클래스 객체 생성
		System.out.println("내가 먼저") //출력
		mycar.run() //3. Car클래스의 run() 메소드 실행
	}
}

>>> "내가 먼저"
>>> 50
```



## 싱글톤
==**싱글톤(singleton)**==: **각 클래스 당 하나의 객체만 생성**하도록 보장하는 코딩 기법

**싱글톤 작성 방법**
1. 외부 클래스에서 자신(클래스)의 생성자가 호출되는 것을 막기 위해 **private 접근 제한자** 사용 (생성자 스스로를 감추어 그 모습을 숨김)
2. 정적 필드를 선언 후 자신의 객체를 초기화 (클래스 내에서 스스로를 인스턴스화)
3. 외부에서 호출할 수 있는 getInstance() 선언 (외부에서 부를 수 없게 된 클래스 내에서 유일하게 호출 가능한 공간 생성) 
4. 정적 필드가 참조하는 자신의 객체를 리턴 (외부에서 호출할 수 있는 공간에 자신의 객체를 참조한 변수를 리턴해 줌)

```java
public class 클래스명{
	//2.
	private static 클래스명 참조변수명 = new 클래스명();
	//private인 static 필드를 선언하여 스스로 인스턴스화
	
	//1.
	private 클래스명() {} //외부에서 클래스를 호출할 수 없도록 닫아버림
	
	//3.
	static 클래스명 getInstance(){ //외부에서 호출 가능한 부분
		//4.
		return 참조변수명; //자신의 객체를 참조한 변수를 리턴해줌
	}
}
```
**즉, 다른 클래스에서 자신의 객체를 생성할 수 없게 만든 다음, 스스로의 객체를 내부에서 생산하여 그 객체를 참조한 변수만 빌려주는 것!**


## final 필드와 상수
### final 필드
==**final 필드**==: 한 번 초기화하면 값을 수정할 수 없는 필드

##### final 필드의 초기값을 초기화하는 방법
**필드 선언 시 초기화** (주로 상수인 정적 필드)
```java
final int x = 5;
```

**생성자에서 초기화** (주로 인스턴스 필드)
```java
public 클래스1(){ //클래스 선언
	final String x;	//final 필드 생성
	
	public 클래스1(String x){ //외부에서 이 생성자를 통해 객체를 생성하면서 x를 초기화
		this.x = x;
	}
}


//외부 클래스
public 클래스2{
	클래스1 y = new 클래스1(5);
	//x가 5이며 수정할 수 없는 객체 생성
}
```


### 상수
==**상수(constant)**==: 𝜋와 같이 변하지 않는 값(**static final**: 정적 final 필드)
- 그냥 final만 사용하면 바꿀 수 없다는 뜻

**정적 final 필드**(관례적으로 모두 **대문자**로 작성)
```java
static final double PI = 3.14; //상수라는 것을 알려주기 위해 대문자로 작성
```



## 패키지
==**패키지**==
- 파일 시스템의 "폴더"
- 클래스의 이름이 같더라도 패키지가 다르면 **다른 클래스로 인식**
- 클래스의 전체 이름은 \[**패키지.클래스**]로 표현
	- 상위패키지.하위패키지.클래스


### 패키지 및 클래스 생성
JDK11 이후부터는 패키지에 속하지 않은 클래스를 생성하면 컴파일 에러가 발생한다.

>프로젝트 폴더(src) 우클릭 - \[new] - \[Package] 


### 패키지 선언
클래스 작성 시, **클래스가 어느 패키지에 소속될 것인지 선언**
```java
package 상위패키지.하위패키지; //패키지 선언

public class ClassName{ //클래스 선언

}
```

**패키지 작명 규칙**
- 숫자로 시작 **불가**
- \_와 &를 제외한 특수문자 사용 불가
- java로 시작하는 패키지는 자바 표준 API 고유이므로 **사용 불가**
* ==**모두 소문자**==로 작성하는 것이 관례


#### import문
사용하고자 하는 클래스 및 인터페이스가 다른 패키지에 소속된 경우, 이를 **현재 패키지로 가져와 사용**할 것임을 컴파일러에게 통지

**패키지 선언문 다음으로 작성한다.**
```java
package 패키지명;

//import문
import 상위패키지.하위패키지.클래스이름;//클래스 하나만 가져올 경우

import 상위패키지.하위패키지.*;//해당 패키지의 클래스를 모두 가져올 경우
```

**같은 이름의 클래스가 존재하는 클래스를 인스턴스화 할 때는
인스턴스화 할 때 패키지명을 모두 써줘야 한다.**
```java
상위패키지.하위패키지.클래스이름 참조변수명 = new 상위패키지.하위패키지.클래스이름(); 
```


## 접근 제한자
==**접근 제한자(access modifer)**==: 클래스와 인터페이스 및 그 밑의 멤버에 대한 **접근 수준 정의**
- **public**: 외부 클래스 모두 자유롭게 사용 가능
- **protected**: 같은 패키지 또는 자식 클래스에서 사용 가능
- **default**: 같은 패키지만 사용 가능 (접근제한자를 별도로 정의하지 않을 경우)
- **private**: 외부에서 사용 불가


### 클래스와 생성자의 접근 제한
```java
//default 접근 제한
class 클래스명{

}

//public 접근 제한
public class 클래스명{

}
```

==클래스는 **public, default** 둘 중 하나만 사용 가능하며==
==**클래스와 생성자는 반드시 같은 접근 수준을 가져야 한다.**==
```java
public class 클래스명{
	public 클래스명(){ //클래스가 public으로 선언되었으므로 생성자도 public
	
	}
}
```


### 필드와 메소드의 접근 제한
다음과 같이 구성된다
default는 기본값이기 때문에 작성하지 않는다.
```java
//필드 선언
[public | protected | private] [final] [static] 타입 필드명;

//메소드 선언
[public | protected | private] [static] 리턴타입 메소드명(...){

}
```

예시)
```java
//필드 선언
public final int x = 5;

//메소드 선언
private String y( ... ){

}
```


### Setter, Getter 메소드
외부에서 객체에 마음대로 접근할 경우 객체의 무결성이 훼손될 수 있다.

#### Setter 메소드
==**외부의 값을 받아 필드의 값을 변경**==할 때, 매개값을 검증하여 유효한 값만 필드로 저장
```java
void x(double speed){
	if(speed < 0){ //speed가 음수로 초기화되는 경우 speed를 0으로 수정
		this.speed = 0;
		return;
	} else{ //speed가 0이상인 경우 초기화된 값을 그대로 사용
		this.speed = speed;
	}
}
```


#### Getter 메소드
==**외부로 필드값을 전달할 때**==, 필드의 값을 **수정**하여 외부로 전달
```java
double x(){
	double cm = mm*10; //mm값을 cm로 전달하기 위해 10을 곱한 후 리턴
	return cm;
}
```


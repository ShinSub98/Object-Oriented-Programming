==**중첩 클래스(nested class)**==
- **클래스 내부에서 선언한 클래스**
- 내외부 클래스 간 멤버 접근을 용이하게 하며, 외부에게 **불필요한 클래스는 감춘다.**
- 복잡한 코드를 보기 쉽게 한다.
```java
class 외부클래스{
	class 내부클래스{
	
	}
}
```

==**중첩 인터페이스**==
- **클래스 내부에서 선언한 인터페이스**
- 외부 클래스와 긴밀한 관계를 갖는 인터페이스를 만들기 위함
```java
class 외부클래스{
	interface 내부인터페이스{
	
	}
}
```


## 중첩 클래스
==**멤버 클래스**==: 클래스의 멤버로서 선언되는 중첩 클래스
(파일명: 외부클래스$내부클래스.class)
- **인스턴스 멤버 클래스**: 외부 클래스의 객체를 생성해야 사용할 수 있는 클래스
- **정적 멤버 클래스**: 외부에서 바로 접근 가능한 내부 클래스

==**로컬 클래스**==: **메소드 내부에서 선언**되는 중첩 클래스로, 메소드를 실행할 때만 사용되고 **종료되면 사라진다.**
(파일명: 외부클래스$1내부클래스.class)


### 멤버 클래스
#### 인스턴스 멤버 클래스
static 없이 선언된 내부 클래스로, **인스턴스 필드 및 메소드만 선언 가능하다.**
```java
class A{
	class B{ //인스턴스 멤버 클래스
	}
}
```

인스턴스 멤버 클래스의 객체를 생성하려면 먼저 **외부 클래스의 객체부터 생성해야 한다.**
```java
외부클래스 참조변수1 = new 외부클래스();
외부클래스.내부클래스 참조변수2 = 참조변수1.new 내부클래스();
```

예)
```java
class A{
	class B{ //인스턴스 멤버 클래스
		int x;
	}
}

class main{
	public static void main(String[] args) {
		A a = new A(); //외부 클래스 객체 생성
		A.B b = a.new B(); //외부 클래스를 통해 객체 생성
		
		b.x = 5;
	}
}
```


#### 정적 멤버 클래스
인스턴스 멤버 클래스와 달리 객체를 생성할 때 외부 클래스의 객체를 만들 필요가 없다.
또한 생성자와 인스턴스 필드/메소드, 정적 필드/메소드 등 **모든 종류의 멤버를 선언할 수 있다.**
```java
class A{
	static class B{ //정적 멤버 클래스
		int x;
	}
}

class C{
	A.B b = new A.B(); //외부 클래스인 A 인스턴스화 없이 바로 생성
	b.x = 5;
}
```


#### 사용 제한
**정적 멤버 클래스는 내부에서 외부 클래스의 인스턴스 멤버를 사용할 수 없다.**
```java
class A{
	int x; //인스턴스 필드
	static int y; //정적 필드
	
	static Class B{
		x=5; //인스턴스 멤버이기 때문에 불가능
		y=5; //정적 멤버이기 때문에 가능
		
	}
}
```


### 로컬 클래스
메소드 내에서 선언한 중첩 클래스로, **접근 제한자 및 static을 함께 선언할 수 없다.**
또한 static으로 선언될 수 없기 때문에 **정적 멤버 또한 선언할 수 없다.**

로컬 클래스는 메소드가 실행될 대, **메소드 내에서 객체를 생성한 후에 사용해야 한다.**
주로 ==**비동기 처리**==를 위해 스레드 객체를 만들 때 사용한다.
```java
class A{
	void method(){
		class B{ //로컬 클래스 선언
		}
		B b = new B(); //메소드 내에서 인스턴스화
	}
}
```


#### 사용 제한
일반 객체와 달리, 로컬 클래스는 메소드가 종료되면 소멸하기 때문에 **매개 변수 및 로컬 변수 또한 함께 소멸한다.**
==**로컬 스레드 객체**==의 경우 메소드가 종료되어도 남아있기 때문에 이미 사라진 매개 변수 및 로컬 변수를 수정하려고 하면 컴파일 에러가 발생한다.

따라서 **로컬 클래스 내부에서 사용되는 매개 변수나 로컬 변수는 `final`을 사용해 선언**해야 하며
자바8부터는 `final`를 작성하지 않아도 자동으로 `final` 특성이 부여된다.
```java
public class 외부클래스{
	public void method(final int arg){
		int x = 1;
		arg = 100; //x와 arg는 로컬 클래스에서 사용되기 때문에 final을 자동 적용
		class 내부클래스{
			public void method(){
				int result = arg + localVariable;
			}
		}
	}
}
```


### 외부 클래스 참조
내부 클래스가 외부 클래스를 참조하기 위해서는 `this.` 키워드를 사용하여 참조한다.
```java
외부클래스.this.필드
외부클래스.this.메소드();
```

예)
```java
public class Outter{
	String str = "외부 필드"
	
	class Nested{
		String str = "내부 필드"
		void print(){
			System.out.println(this.str); //내부 클래스의 필드값
			System.out.println(Outter.this.str); //외부 클래스의 필드값
		}
	}
}

>>> "내부 필드"
>>> "외부 필드"
```



## 중첩 인터페이스
==**클래스 내부에서 선언된 인터페이스**==
해당 클래스와 긴밀한 구현 클래스를 만들기 위해 사용한다.
```java
//외부 클래스와 중첩 인터페이스
class A{
	[static] interface I{ //중첩 인터페이스
		void method();
	}
}

//인터페이스 I의 구현 클래스
public class C implements A.I{
	@Override
	void method(){
		~
	}
}
```

인스턴스/정적 멤버 인터페이스 모두 선언 가능하다.
- **인스턴스 멤버 인터페이스는 외부 클래스의 객체를 먼저 생성해야 사용할 수 있다.**
- **정적 멤버 인터페이스는 외부 클래스 객체 없이 바로 접근할 수 있다.**



## 익명(anonymous) 객체
==**이름이 없는 개체**==
일반적인 경우, **객체를 선언할 때 클래스를 명시**하지만
익명 객체를 생성할 때는 부모 클래스가 이름이 없는 자식 객체를 참조하고
인터페이스 변수는 이름이 없는 구현 객체를 참조한다.
```java
//상속
부모클래스 참조변수 = new 부모클래스() {클래스 내 내용}; //이름이 없는 자식 객체를 참조한다.

//구현
인터페이스 참조변수 = new 인터페이스() {인터페이스 내 내용}; //이름이 없는 구현 객체를 참조한다.
```

익명 객체는 보통 **많이 사용하지 않는 클래스 및 인터페이스의 객체를 만들 때 사용**한다.
즉, 구현 클래스 등을 만들지 않고 바로 객체로 만들어준다.


### 익명 자식 객체 생성
==자식 클래스를 재사용하지 않고 **특정 위치에서만 사용**하는 경우==(1회성 객체)
```java
부모클래스 [필드|변수] = new 부모클래스(매개값...) {
	//필드
	//메소드
}; //객체 선언문과 같기 때문에 ;으로 마무리
```
매개값은 부모 클래스 생성자에 맞게 넣어주면 된다.
부모 클래스를 상속하여 { } 안의 내용대로 자식 클래스를 선언하라는 의미이며
부모 클래스의 메소드를 재정의 할 수도 있다.
또한 이 경우 ==**생성자를 선언할 수 없다.**==

- **필드를 초기화 할 때 자식 객체를 생성하여 대입**
```java
class A{
	부모클래스 변수명 = new 부모클래스(){ //필드에 익명 자식 객체를 초기화
		//필드
		//메소드
		//재정의된 부모 메소드
	}; //객체 선언문과 같기 때문에 ;으로 마무리
}
```

- **메소드 안에서 로컬 변수로 초기화**
```java
class A{
	void 메소드명(){
		부모클래스 변수명 = new 부모클래스(){ //메소드 내부에서 변수로서 초기화
			//필드
			//메소드
			//재정의된 부모 메소드
		}; //객체 선언문과 같기 때문에 ;으로 마무리
	}
}
```

- **메소드의 매개 변수가 부모 타입인 경우, 메소드를 호출하는 문장에서 익명 자식 객체를 생성하여 매개값으로 대입**
(객체 자체를 매개값으로 넘겨준 것)
```java
class A{
	void method1(부모클래스 변수명){
	
	}

class B{
	A a = new A();
	
	a.method1(
		new 부모클래스() { //method1의 매개값으로 익명 자식 객체를 입력
			//필드
			//메소드
			//재정의된 부모 메소드
		}
	);
}
```

익명 자식 객체에서 새롭게 정의된 멤버는 ==해당 객체 내부에서만 사용할 수 있다.==


### 익명 구현 객체 생성
==**구현 클래스를 재사용하지 않고 특정 위치에서만 사용하는 경우**==(1회성)
```java
인터페이스 [필드|변수] = new 인터페이스(){
	//인터페이스 내의 추상 메소드를 실체 메소드로 선언
	//필드
	//추가 선언 메소드
};
```

- 필드에 익명 구현 객체를 초기화
```java
class A{
	인터페이스명 변수명 = new 인터페이스명(){
		//인터페이스의 추상 메소드에 대한 실체 메소드 작성
	};
}
```

- 메소드 내에서 로컬 변수에 초기화
```java
void method(){
	인터페이스명 로컬변수명 = new 인터페이스명(){
		//인터페이스의 추상 메소드에 대한 실체 메소드 작성
	}
}
```

- 메소드의 매개 변수가 인터페이스 타입일 때, 이 메소드를 호출하는 동시에 익명 구현 객체를 생성하여 매개값으로 입력
```java
class A{
	void method1(인터페이스명 변수명){
	
	}
}

class B{
	A.a = new A();
	
	a.method1(
		new 인터페이스명(){
			//인터페이스의 추상 메소드에 대한 실체 매소드 작성
		}
	);
}
```


### 익명 객체의 로컬 변수 사용 제한
==**메소드의 매개/로컬 변수를 익명 객체 내부에서 사용할 때 제한이 있다.**==
- 메소드가 종료되어도 익명 객체는 계속 실행 상태로 남아있을 수 있다.
- 하지만 메소드가 종료되면 메소드의 변수들은 소멸하므로 익명 객체 내부에서 지속적으로 사용할 수 없다.
	- 따라서 컴파일러는 익명 객체 내부에서 사용하는 메소드의 매개/로컬 변수들을 **익명 객체 내부에 미리 복사해두고 사용**하며, 이를 **final 취급하여 한 번 초기화된 변수는 수정할 수 없다.**

```java
//인터페이스
public interface I{
	public void methodIn();
}

//API
public class C{
	int x; //익명 객체 외부에서 선언된 필드 x
	
	public void methodOut(int y){
		int z;
		
		int x = 5;
		//int y = 5; 익명 객체의 매개 변수는 final이다.
		//int z = 5; 익명 객체의 로컬 변수는 final이다.
	}
}
```


==**중첩 클래스 정리**==
- 중첩 클래스
	- 정적 멤버 클래스
	- 인스턴스 멤버 클래스
		- 익명 클래스 / 익명 인터페이스
		- 로컬 클래스 / 로컬 인터페이스
		- 내부 클래스 (내부 클래스는 private으로 선언된 외부 클래스의 멤버에도 접근할 수 있다.)



## 예외(Exception)
==**예외(Exception)**==
- 유저의 오조작 및 개발자의 실수로 발생한 오류
- **예외 처리(Exception handling)** 프로그램을 통해 예외가 발생하더라도 정상적인 작동 가능
- 예외 발생 가능성이 높은 코드를 작성할 때 예외 처리 여부를 미리 확인


### 예외와 예외 클래스
==**일반 예외(Exception)**==: 컴파일러가 확인할 수 있는 예외, 컴파일러가 검사하여 예외 처리 코드가 없다면 오류를 발생시켜 개발자에게 알린다.
- RuntimeException을 제외한 **모든 예외**

==**실행 예외(rutine exception)**==: 컴파일러가 확인할 수 없는 예외로, 컴파일 시 발견되지 않는다. 개발자가 책임지고 처리를 해야 한다.
- RuntimeException에 속한 예외


>자바에서는 예외를 **클래스**로 관리한다.
- RuntimeException 클래스는 실행 예외
- 그 외 달느 예외들은 모두 일반 예외이다.


### 실행 예외
**개발자가 자신의 경험을 통해 예외를 파악**하고, 직접 예외 처리 코드를 작성해야 한다.
예외 처리 코드가 없을 경우, 해당 예외가 발생하면 오류로 프로그램이 종료된다.

==**NullPointerException**==
가장 빈번하게 발생하는 예외로, 참조하는 객체가 없는 참조 변수에 **객체 접근 연산자(.)를 사용할 경우 발생**
```java
String x = null;
System.out.println(x.toString()); //객체가 존재하지 않는 x를 불러내려고 함
>>> java.lang.NullPointerException
```

==**ArrayIndexOutOfBoundsException**==
**배열의 범위를 초과**하여 작업할 경우 발생
```java
int x[] = new int[3];

x[4] = 5;
>>> java.lang.ArrayIndexOutOfBoundsException
```

==**NumberFormatException**==
문자열을 숫자로 변환할 때, 문자열에 **숫자로 변환될 수 없는 문자**가 있는 경우 발생

| 리턴 타입 | 메소드 이름(매개 변수)         | 설명                                 |
| --------- | ------------------------------ | ------------------------------------ |
| int       | `Interger.parseInt(문자열)`  | 문자열을 정수로 변환 |
| double    | `Double.parseDouble(문자열)` | 문자열을 실수로 변환 |

```java
String x = "%^%"
int y = Interger.parseInt(x);
>>> java.lang.NumberFormatException
```

==**ClassCastException**==
불가능한 타입 변환을 시도할 경우 발생
아래 관계가 아닌 경우 발생한다.
![](https://i.imgur.com/XQMYUz2.png)
이 경우, instanceof 연산자를 통해 예방할 수 있다.
```java
//자식 클래스인 Dog의 객체가 부모 클래스인 Animal 타입으로 자동 변환
Animal animal = new Dog(); 

if(animal instanceof Dog){ //animal이 Dog의 객체가 맞을 경우에만 강제 타입 변환 시도
	Dog dog = (Dog) animal;
}


//오류 발생 케이스
Animal animal = new Dog();
Cat cat = (Cat) animal; //Dog의 객체인 animal을 Cat 타입으로 강제 변환 시도
>>>java.lang.ClassCastException
```



## 예외 처리
==**예외 처리 코드**==
- 자바 컴파일러가 일반 예외 발생 가능성이 있는 코드를 발견하면 에러를 발생시켜 개발자에게 알린다.
- 실행 예외(RuntimeException)의 경우는 개발자가 직접 확인하여 경험을 바탕으로 작성해야 한다.


### try-catch-finally 블록
**생성자 및 메소드 내부에서 작성**
일반/실행 예외 발생 시 이를 처리할 수 있도록 하는 역할
![](https://i.imgur.com/WsDvUrW.png)

- try 블록에는 예외 발생 가능 코드를 작성
	- try 블록에서 예외가 발생하면 catch 블록 코드 실행 후 finally 블록 코드 실행
	- try 블록에 문제가 없었으면 바로 finally 블록 코드 실행
		- finally 블록은 생략할 수 있으며, 예외와 무관하게 반드시 실행해야 하는 코드를 작성

```java
int x[] = new int[3];

try{
	x[4] = 5;
} catch(ArrayIndexOutOfBoundsException e) {
	System.out.println("배열 범위 초과");
} finally {
	System.out.println("종료");
}
>>> "배열 범위 초과"
>>> "종료"
```


#### 다중 catch
**발생하는 예외가 다양할 경우**, 각 예외별로 처리 코드를 작성하는 다중 catch 블록
- try 블록에서 감지된 예외에 따라 어떤 catch 블록을 선택할지 결정

```java
int x[] = new int[3];

try{
	x[4] = 5; //ArrayIndexOutOfBoundsException 발생
} catch(ClassCastException e) {
	System.out.println("잘못된 타입 변환");
} catch(ArrayIndexOutOfBoundsException e) { //선택
	System.out.println("배열 범위 초과");
}
>>> "배열 범위 초과"
```


다중 catch문을 작성할 때는 반드시 ==**하위 예외 클래스를 먼저 작성하고, 상위 예외 클래스를 아래에 작성**==한다.
상위 예외 클래스는 하위 예외 클래스를 모두 포함하고 있기 때문에
상위 예외 클래스를 먼저 작성할 경우, 더 적절한 catch문이 뒤에 있더라도 상위 예외 클래스를 적용하게 된다.


### throws
메소드 선언부 끝에 작성하며, ==**처리하지 못한 예외를 호출한 곳으로 넘기는 역할**==
`throws` 뒤에는 넘길 예외 클래스를 쉼표로 구분한다.
```java
리턴타입 메소드명(매개변수...) throws 예외클래스1, 예외클래스2,...{
	//메소드 내용
}

리턴타입 메소드명(매개변수...) throws Exception{
	//메소드 내용
}
```

`throws` 키워드가 있는 메소드는 ==반드시 try 블록 내에서 실행==되어야 한다.
또한 `throws`를 통해 넘겨진 예외는 ==catch 블록에서 처리==해야 한다.
```java
void method() throws ClassNotFoundException{
	//예외 발생 가능성이 있는 코드
}

try{
	method(); //method 호출 시 try 블록 안에서 호출
} catch(ClassNotFoundException e) { //예외 발생 시 작동
	//예외 처리 코드
	System.out.println("클래스가 존재하지 않습니다.");
}
```
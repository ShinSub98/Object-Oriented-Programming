==**컬렉션 프레임워크(Collection Framework)**==
- **컬렉션(Collection)**: 객체의 저장
- **프레임워크(Framework)**: 사용 방법을 정해놓은 라이브러리
- 객체들을 효율적으로 관리하기 위한 java.util 패키지의 인터페이스 및 구현 클래스
	- 대표적으로 List, Set, Map 등
![](https://i.imgur.com/oYN6sJ0.png)
## List
==**List 컬렉션**==
- 배열과 비슷하게 객체를 **인덱스**로 관리
- 저장용량이 자동으로 증가해 객체 저장 시 자동으로 인덱스 부여
- 추가, 삭제, 검색 등 다양한 메소드 제공
- **객체 참조 방식**
	- 동일 객체를 중복 참조하면 동일한 주소값을 참조한다.
	- null값도 저장할 수 있지만 참조 주소값이 없음

> [!info] 
> 매개 변수 타입과 리턴 타입의 E는 저장되는 객체의 타입을 **List 컬렉션을 생성할 때 자동으로 결정하라는 뜻**이다.
> 
> Ex) List\<String>으로 list 변수를 선언하면 객체를 String 타입으로 저장한다.

 

### 객체 추가
|             메소드             | 설명                                         |
|:------------------------------:| -------------------------------------------- |
|       `boolean add(E e)`       | 주어진 객체를 맨 끝에 추가                   |
| `void add(int idx, E element)` | 주어진 인덱스에 객체 추가                    |
|  `E set(int idx, E element)`   | 해당 인덱스에 저장된 객체를 다른 객체로 대치 |


### 객체 검색
|            메소드            | 설명                               |
|:----------------------------:| ---------------------------------- |
| `boolean contains(Object o)` | 주어진 객체가 저장되어 있는지 조사 |
|       `E get(int idx)`       | 주어진 인덱스에 저당된 객체를 리턴 |
|     `boolean isEmpty()`      | 저장되어 있는지 조사               |
|         `int size()`         | 저장되어 있는 전체 객체 수를 조사  |


### 객제 삭제
|           메소드           | 설명                               |
|:--------------------------:| ---------------------------------- |
|       `void clear()`       | 저장된 모든 객체를 삭제            |
|    `E remove(int idx)`     | 주어진 인덱스에 저장된 객체를 삭제 |
| `boolean remove(Object o)` | 주어진 객체를 삭제                 |


### ArrayList
List 인터페이스의 대표적인 구현 클래스
- 초기 용량은 10개의 객체를 저장 가능
- 객체를 추가하면 **0번 인덱스부터 차례로 저장**
- 객체를 삭제하면 뒤 객체들의 인덱스가 모두 당겨진다.
```java
//1.
List<E> 변수명 = new ArrayList<E>();

//2.
List<String> 변수명 = new ArrayList<>(); //이 경우 왼쪽의 타입을 따라감
```


### Vector
ArrayList와 구조는 같지만 ==객체 타입을 E로 표기==하고 **기본 생성자를 호출하여 생성**
```java
//1.
List<E> lsit = new Vector<E>();

//2.
List<E> list = new Vector<>(); //이 경우 왼쪽의 타입을 따라감
```
- 동기화 메소드로 되어있기 때문에 **멀티 스레드가 동시에 이용할 수 없음**
	- 멀티 스레드 환경에서 안전하게 객체 추가 및 삭제 가능


### LinkedList
ArrayList와 **사용 방법은 같지만 내부 구조가 다름**
- 인접 참조 객체와 연결되어 객체를 관리
- 특정 객체를 제거/삽입하면 앞뒤 링크만 변경되고 나머지는 그대로임. 즉, 움직이지 않음

|    구분    | 순차적으로 추가/삭제 | 중간에 추가/삭제 |  검색  |
|:----------:|:--------------------:|:----------------:|:------:|
| ArrayList  |        빠르다        |      느리다      | 빠르다 |
| LinkedList |        느리다        |      빠르다      | 느리다 |



## Set 컬렉션
List와 다르게 **객체에 인덱스를 부여하지 않고 저장**
- 따라서 인덱스를 통해 객체를 검색 및 출력하는 메소드가 없다.
- 그 대신 반복자 객체의 `iterator()` 메소드를 통해 검색 기능을 대체
==객체를 중복하여 저장할 수 없으며==, 따라서 null도 하나만 저장할 수 있다.


### 객체 추가
| 메소드             | 설명                                                                 |
| ------------------ | -------------------------------------------------------------------- |
| `set.add(E e)` | 주어진 객체를 저장하며 저장을 성공하면 true를, 실패하면 false를 리턴 |


### 객체 검색
| 메소드                       | 설명                                         |
| ---------------------------- | -------------------------------------------- |
| `set.contains(Object o)` | 주어진 객체가 저장되어 있는지 조사           |
| `set.isEmpty()`          | 컬렉션이 비어있는지 조사                     |
| `Iterator<E> x = set.iterator()`     | 저장된 객체를 한 번씩 가져오는 반복자를 리턴 |
| `set.size()`                 | 저장되어 있는 전체 객체 수를 리턴합니다.     |


### 객체 사실
| 메소드                     | 설명                    |
| -------------------------- | ----------------------- |
| `set.clear()`             | 저장된 모든 객체를 삭제 |
| `set.remove(Object o)` | 주어진 객체를 삭제      |


### Iterator 인터페이스 메소드
| 리턴 타입 |   메소드    | 설명                                           |
|:---------:|:-----------:| ---------------------------------------------- |
|  boolean  | `iterator.hasNext()` | 가져올 객체가 있으면 true, 없으면 false를 리턴 |
|     E     |  `iterator.next()`   | 컬렉션에서 하나의 객체를 불러온다              |
|   void    | `iterator.remove()`  | Set 컬렉션에서 객체를 제거                     |
- `next()` 메소드를 사용하기 전에 `hasNext()` 메소드를 사용해 존재 여부를 확인하는 것이 좋다.
	- 먼저 `hasNext()` 메소드를 사용한 후 true가 리턴되면 `next()` 메소드를 사용

```java
Set<String> set = ... ;
Iterator<String> iterator = set.iterator();

while(iterator.hasNext()){
	String str = iterator.next(); //
}
```


### HashSet
Set 인터페이스의 구현 클래스로, 기본 생성자를 호출하여 생성
- 위 설명과 같이 동일 각 객체를 순서 없이 저장하며 동일 객체는 중복 저장하지 않는다.
	- 객체를 저장하기 전 `hashCode()` 메소드를 통해 기존 객체와 해시코드를 비교해 중복 여부를 확인한다.
```java
Set<E> set = new HashSet<E>();
//혹은
Set<E> set = new HashSet<>();
```



## Map 컬렉션
<u>키(Key)</u>와 <u>값(Value)</u>로 구성되며 ==**Map.Entry**== 객체에 저장
- Entry는 Map 인터페이스 내부에 선언된 **중첩 인터페이스**
- 키는 중복 저장 불가 / 값은 중복 저장 가능
	- 기존에 존재하는 키에 값을 저장하면 ==값이 대치==됨

### 객체 추가
| 메소드                 | 설명                                                                                                             |
| ---------------------- | ---------------------------------------------------------------------------------------------------------------- |
| `V put(K key.V value)` | 주어진 키에 값을 저장. 새로운 키일 경우 null을 리턴,<br>동일한 키가 있을 경우 새로운 값으로 대치하고 기존 값을 리턴 |


### 객체 검색
|              메소드               | 설명                                    |
|:---------------------------------:| --------------------------------------- |
|   `map.containsKey(Object key)`   | 주어진 키의 존재 여부 확인              |
| `map.containsValue(Object value)` | 주어진 값의 존재 확인                   |
| `Set<Map.Entry<K.V>> entrySet()`  | Map.Entry 객체를 Set에 리턴             |
|         `V get(Object key)`         | 주어진 키가 있는 값을 리턴              |
|          `map.isEmpty()`          | 컬렉션이 비어 있는지 여부 확인          |
|         `Set<K> keySet()`         | 모든 키를 Set 객체에 담아 리턴          |
|           `int size()`            | 저장된 키의 총 개수를 리턴              |
|     `Collection<V> values()`      | 저장된 모든 값을 Collection에 담아 리턴 |


### 객체 삭제
|         메소드         | 설명                                                |
|:----------------------:| --------------------------------------------------- |
|     `map.clear()`      | 모든 Map.Entry를 삭제                               |
| `V remove(Object key)` | 주어진 키와 일치하는 Map.Entry를 삭제하고 값을 리턴 |





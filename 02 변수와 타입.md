## 변수
**변수(Variable)**: 값을 저장할 수 있는 메모리 주소에 붙이는 이름 (≠ 자료)
- 해당 번지에 하나의 값을 저장하고 읽을 수 있다.
- 자바에서는 변수와 자료의 자료형을 잘 맞추어 사용해야 한다.

### 변수의 속성
1. 이름: 변수명
2. 주소:  변수의 값이 저장될 메모리 상의 주소
3. 값: 배정문(=)에 의해 부여되는 자료의 값
4. 타입: 변수가 가질 값의 범위와 이에 대한 연삽들의 집합 (= 자료형)
5. 영역: 해당 변수에게 사용이 허락되는 범위 (전역/지역)
6. 수명: 변수가 유지되는 기간 (Garbage Collector가 삭제할 때까지의 기간)

### 변수 선언
**변수 선언**: 변수명과 자료형을 결정

#### 변수 작명 규칙
1. 첫 글짜는 문자, ‘$’, ‘_’이어야 하며, 숫자로 시작할 수 없다.
2. 영어 대소문자는 시스템 적으로 구분된다.
3. 변수명 길이에는 제한이 없다.
4. 자바의 예약어(해당 언어에서 의미를 가지고 사용되는 단어)는 사용할 수 없다.
5. 관례적으로, 첫 글짜는 소문자를 사용하며 여러 단어를 붙여 쓸 경우 대문자로 구분한다. (≒띄어쓰기를 대문자로)

**예약어**: 자료형, 논리값, 반복문 등

### 값 저장
변수에 값을 저장할 경우 **대입 연산자(=)**를 사용
```
int score; //변수 선언
score = 90; //값 저장(= 초기화)
```

**변수 초기화**: 변수에 최초로 값을 저장하여 메모리 내에 변수를 생성하는 것.
- 초기값: 변수를 초기화 할 때 저장된 값
- 초기화 하지 않은 변수(선언만 한 상태)는 메모리 안에 없으며 값을 읽을 수 없음


### 디버깅(Debugging)
![](https://i.imgur.com/37n5eau.png)



1. 라인 번호 왼쪽을 클릭하여 Break point(멈추는 지점)을 설정할 수 있다.
Break point를 설정하면 해당 프로그램이 해당 라인에서 멈춘다.
![](https://i.imgur.com/g4OjarK.png)


2. 디버깅 버튼을 누른다.
![](https://i.imgur.com/Hs7KMjN.png)


3. 화면 우측에 우측에 디버깅 뷰가 생성된다.
변수 탭에서 각 변수 좌측에 ‘L’은 Local이라는 뜻으로, 해당 메소드 안에서만 사용 가능한 **지역변수**라는 것을 의미하며, 이는 로그가 아닌 현재 메모리의 “실시간 상황”을 나타낸다.
한 메소드가 끝나면 **해당 메소드 내의 변수가 목록에서 모두 사라진다.**
![](https://i.imgur.com/ccDJUqf.png)


4. 이후 Step into(좌), Step over(우)를 사용해 소스를 조금씩 실행시킬 수 있으며 우측의 디버깅 뷰를 통해 코드가 진행되는 정황을 확인할 수 있다.
- Step into: 함수 등에서 사용하면 **해당 함수 내부로 들어가** 함수의 첫째줄로 이동한다.
- Step over: 함수 등에서 사용하면 **해당 함수의 과정을 건너뛰어** 바로 함수의 결과를 출력한다.
![](https://i.imgur.com/tbSJgr0.png)



5. 콘솔의 빨간 아이콘은 해당 메소드가 아직 실행중임을 나타낸다.


### 변수 사용
변수 사용: 변수 값을 이용해 출력문/연산식을 수행하는 것.

변수 값 복사: 변수의 값을 다른 변수에 저장
`int y = x;`

**로컬 변수**: 메소드 블록 내에서 선언된 변수를 로컬 변수라고 하며, 해당 메소드가 끝나면 삭제된다.
![](https://i.imgur.com/rdLKO5J.png)


즉, 로컬 변수는 본인이 만들어진 중괄호( { } ) 안에서만 사용할 수 있다.
![](https://i.imgur.com/1ag0yja.png)


> **메소드 블록 전체에서 사용하려면 메소드 블록 첫머리에, 지역적으로 사용하려면 해당 블록 내부에서 선언**


## 기본 자료형(타입)
**기본 타입**
- 정수 타입: byte, char, short, int, long
- 실수 타입: float, double
- 논리 타입: boolean


### 정수 타입
**메모리 사용량**과 **저장되는 값의 허용 범위**에 따라 다름
![](https://i.imgur.com/f044H4H.png)

- 메모리 크기: byte < short =char < int < long
	- char는 short의 크기만큼 음수가 아닌 값들을 저장할 수 있다.

**리터럴**(literal): 소스 코드에서 **프로그래머에 의해 직접 입력된 값**
- 자바에서는 2, 8, 10, 16진수를 작성하면 정수로 인식하기 때문에 출력하면 자동으로 10진수로 출력된다.
	- 2진수: 0b 또는 0B로 시작
	- 8진수: 0으로 시작
	- 16진수: 0x 또는 0X로 시작

char는유니코드 범위를 가지고 있어 정수와 문자 모두 저장할 수 있으며, 출력할 땐 해당 유니코드가 나타내는 **’문자’로 출력된다.**

### 문자열
큰 따옴표로 감싼 문자.(“ “)
한 글자의 문자는 작은 따옴표를 사용한다. (‘ ‘)
char에는 문자만 저장할 수 있으며 ‘문자열’은 저장할 수 없다.

* String 타입: 문자열을 저장하는 변수 타입
	* `String var1 = "A"`

> 정수형 변수에는 데이터의 메모리 주소가 아닌 해당 값이 저장되지만, 문자열인 String 타입의 변수는 해당 데이터를 직접저장하는 것이 아닌 주소 값을 저장하는, **참조변수**이다.

![](https://i.imgur.com/jffSAsJ.png)

위 이미지는 “홍길동”이라는 문자열이 저장된 객체를 나타낸 것으로, 객체의 주소와 문자열을 구성하는 문자에 해당하는 값이 쓰여 있다.

### 이스케이프(Escape) 문자
문자열 내부에 있는 \를 의미하며, 이스케이프 문자를 사용하면 특정 문자를 포함시키거나 문자열의 출력을 제어할 수 있다.( “ “등을 문자열 안에 넣거나 줄넘김을 하는 등이 가능)
- \\t: 탭 만큼 띄움
- \\n: 줄 바꿈(라인 피드)
- \\r: 캐리지리턴
- \”: “ 출력
- \’: ‘ 출력
- \\: \\ 출력
- \u16진수: 16진수 유니코드에 해당하는 문자 출


### 실수 타입
![](https://i.imgur.com/XU0qLbO.png)

float와 double 모두 **0을  0.0으로 표현한다.**

자바는 실수를 기본적으로 double에 저장하기 때문에 float로 저장할 때
그냥 `float x = 3.14;`로 작성하면 컴파일 시 에러가 발생한다.
따라서 `float x = 3.14f;`와 같이 실수 끝에도 f나 F를 붙여줘야 한다.


알파벳 e 또는 E가 포함된 숫자 리터럴은 지수와 가수로 표현된, 소수점이 있는 10진수 실수로 인식한다. (e5 는 10^5로 인식)
* 5e2 -> 5.0 × 10^2 = 500.0
* 0.12E-2 -> 0.12 × 10^(-2) = 0.0012


### 논리 타입
참/걱짓을 표현하는 true와 false 리터럴을 저장한다.
`boolean x = ture;`

## 타입 변환
데이터 타입을 다른 데이터 타입으로 변환하는 것
Ex) 
```java
byte a = 10;
int b = a; //byte인 a의 값 10을 int인 b에 저장
```


### 자동 타입 변환(Promotion)
**범위가 작은 타입에서 큰 타입으로 복사/이동할 경우**, 유실되는 정보가 없기 때문에 자동적으로 변환된다.
```java
byte x = 10;
int y = x; // x의 타입인 byte보다 y의 int의 허용 범위가 크기 때문에 자동으로 변환
```

**기본 타입의 허용 범위 순서**
byte < short < int < long < float < double

char의 경우, int로 변환되면 문자가 아닌 유니코드(정수)의 값이 저장된다.
```java
char x = 'A';
int y = x; // y는 int이므로 'A'가 아닌 65가 저장된다.
//반대로 y -> x의 경우 컴파일에러가 발생한다.
```

### 강제 타입 변환(Casting)
큰 허용 범위의 타입에서 작은 허용 범위의 타입으로 변환할 때, **강제로 나누어 저장**하는 것
```java
int x = 10;
byte y = (byte) x; //int→byte로 강제 변환
```

```java
double x = 3.14;
int y = (int) x; //y는 정수형인 int이므로 정수 부분인 3만 저장된다.
```

#### 정수 연산에서의 자동 타입 변환
정수 연산 시 **피연산자에 long 타입이 없는 경우**, 피연산자들이 자동으로 int로 바뀐 뒤 연산된다.
따라서 이 연산식을 다른 변수에 초기화할 경우엔, 해당 변수도 int로 선언해야 하며
피연산자로 사용되는 변수들도 처음부터 int로 선언하는 것이 작업 속도 측면에서도 효율적이다.
```java
byte x = 5;
short y = 30;
int z = x + y; //x와 y 모두 int로 바뀌어 연산되었으므로 이를 받는 z도 int로 선언
//z를 다른 타입으로 받으면 컴파일 에러가 뜬다.
```

**피연산자 중 하나가 long 타입인 경우**엔 다른 피연산자들도 long 타입으로 변환된다.
```java
long x = 5;
short y = 30;
long z = x + y; // x가 long이기 때문에 y도 long으로 바뀌여 연산된다.
```

#### 실수 연산에서의 자동 타입 변환
**피연산자 중 하나가 double인 경우**엔 다른 피연산자도 자동으로 double로 변환된다.
```java
double x = 5.5;
int y = 3;
double z = x + y; // x가 double이므로 y도 자동으로 double로 변환된다.
```

정수/실수 공통) 초기화되는 변수와 타입이 달라 변환한 뒤 연산되어야 하는 경우엔 개발자가 직접 강제변환 한 뒤 연산을 수행해야 한다.
```java
int x = 10;
double y = 5.5;
int z = x + (int)y; //변수 z가 int로 선언되었으므로 y 또한 int로 변환하여 연산해야 한다.
```

```java
double x = 5.5;
float y = 3.5f;
float z = (float)x + y;
```

#### 정수 연산의 결과를 실수로 저장할 때
정수끼리 연산한 결과는 그 값이 실수라고 하더라도 **타입 상 정수로 취급된다.**
따라서 연산 결과를 바로 실수 변수로 받는 것이 아니라, 연산 결과도 실수로 변환해줘야 한다.
```java
int x = 1;
int y = 2;

//잘못된 케이스
double z = x/y; //연산 결과는 1/2이지만 int로 취급되기 때문에 z를 출력하면 0.0이 출력된다.

//방법1
double z = (double)x/y //x나 y 둘 중 하나를 double로 변환하거나

//방법2
double z = (double)x/(double)y //아예 둘 다 변환하는 방법도 있다.
```

#### 더하기(+) 연산에서의 문자열
피연산자 중 하나가 문자열일 경우 **나머지도 문자열로 자동 변환하여 연산**
```java
int x = 3 + "7";
>>> "37"
```

이 때, 연산은 앞에서부터 순서대로 진행되므로 문자열보다 앞선 부분은 숫자로서 연산된다.
```java
int x = 3 + 7 + "10";
>>> 10 + "10"
>>> "1010"
```


### 문자열 타입 변환
숫자로 된 문자열을 기본 타입으로 강제 변환(parse)
![](https://i.imgur.com/0wLG76F.png)

-> 문자열이 숫자 외 문자를 포함할 경우엔 “NumberFormatException”에러가 발생한다.

`String.valueOf()`메소드를 사용하여 기본 타입들을 문자열로 변환할 수 있다.
```java
String x = String.valueOf(3)
>>> "3"
```



## 변수와 시스템 입출력
표준 출력 장치: 모니터
표준 입력 장치: 키보드

`System.out`: 시스템의 표준 출력 장치(모니터)로 출력 (≒ print)
`System.in`: 시스템의 표준 입력 장치(키보드)에서 읽음 (≒ input)

### 출력
출력 메소드
`println();`: 괄호 안의 내용을 출력하고 **줄바꿈**
`print();`: 괄호 안의 내용을 출력
`printf("형식문자열", 값1, 값2, ...);`: 괄호 안의 첫 번째 문자열을 형식대로 출력

#### printf() 메소드
개발자가 원하는 형식으로 형식화된 문자열(formal string) 출력 (전체 출력 자리수 및 소수 자리수에 제한이 있다.)
![](https://i.imgur.com/uCMtV0n.png)


`printf("문자열%[순번][지표][자리수][소수자리수(=정밀도)] s or d", "값")`

위 요소 중 %와 conversion(변환 문자) 외에는 모두 생략될 수 있다.
conversion에는 제공되는 값의 타입에 다라 d(정수), f(실수), s(문자열)을 입력한다.

ex. 형식문자열에 입력될 값이 하나인 경우
```java
System.out.printf(“이름: %s”, “홍길동”);
>>> "이름: 감자바"
```


ex. 형식문자열에 입력될 값이 복수인 경우 값의 순서를 표시 (≒파이썬의 {0}.format())
```java
System.out.printf("이름: %1s, 나이: %2d", "홍길동", 25);
>>> "이름: 홍길동, 나이: 25"
```


![](https://i.imgur.com/oStc3sx.png)



### 입력
#### 키코드(KeyCode)
- 키보드에서 키를 입력할 때 프로그램에서 **숫자로 된 키코드**를 읽어들임
-  `int x = System.in.read();`
	- System: 시스템이 가지고 있는
	- in: 입력 장치에서
	- read(): 입력된 코드를 읽기
- 얻은 값은 int 변수에 저장
- **엔터, 탭 등의 기능키**와 **방향키** 모두 입력 가능

- 윈도우 환경에서는 키코드 입력 시 엔터를 누르면 엔터를 눌렀을 때의 13, 떼었을 때의 10이 함께 입력된다.
``
**무한반복으로 키코드 읽기(+ 종료키)**
```java
while(true){
	keyCode = System.in.read(); //while(true)이므로 무한반복
	System.out.println("keyCode: " + keyCode);
	if(keyCode == 113){ //키코드 113(q)가 입력될 경우의 조건문
		break; // 종료하면 아래 { } 통과
		}
		System.out.println("종료") //while문을 벗어나면 작동
}
```

System.in.read()의 단점
* 한글과 같이 여러 키가 조합되는 문자는 읽을 수 없음
* 문자열을 읽을 수 없음


##### 입력된 여러 문자, 문자열을 변수에 저장하기 (Scanner)
**Scanner**: Scanner 클래스를 이용하여 문자열을 읽을 수 있음

Scanner를 사용하기 위해서는
```java
import java.util.Scanner;
```
를 입력하여 Scanner 클래스를 import 해야 한다.

**적용 방법**
```java
Scanner x = new Scanner(System.in);
//new Scanner(System.in)를 받는
//Scanner 클래스로 만들어진 참조변수 x를 선언

// 문자열을 받을 때
String y = x.nextLine(); //.nextLine(): 엔터 이전까지의 문자열을 읽는 명령어
//String 변수 y 선언
//nextLine()을 x에 넣은 후, 이를 다시 y에 저장

// 정수 등을 받을 때
int z = x.nextInt();
```


##### 값의 비교 (기본 타입 / 문자열)
**기본 타입의 값 비교**
* == 를 사용
```java
inx x = 5;
boolean y = (x==5); //x는 5가 맞으므로 y에는 true가 저장됨
```

**문자열의 값 비교**
* equal()을 사용
```java
boolean y = x.equals("비교할 문자열"); //x와 y가 같다면 true를 저장
```

